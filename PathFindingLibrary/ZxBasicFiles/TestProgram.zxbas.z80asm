	.zxbasic
	org 25000
.core.__START_PROGRAM:
	di
	push ix
	push iy
	exx
	push hl
	exx
	ld hl, 0
	add hl, sp
	ld (.core.__CALL_BACK__), hl
	ei
	call .core.__MEM_INIT
	call .core.__PRINT_INIT
	jp .core.__MAIN_PROGRAM__
.core.__CALL_BACK__:
	DEFW 0
.core.ZXBASIC_USER_DATA:
	; Defines HEAP SIZE
.core.ZXBASIC_HEAP_SIZE EQU 256
.core.ZXBASIC_MEM_HEAP:
	DEFS 256
	; Defines USER DATA Length in bytes
.core.ZXBASIC_USER_DATA_LEN EQU .core.ZXBASIC_USER_DATA_END - .core.ZXBASIC_USER_DATA
	.core.__LABEL__.ZXBASIC_USER_DATA_LEN EQU .core.ZXBASIC_USER_DATA_LEN
	.core.__LABEL__.ZXBASIC_USER_DATA EQU .core.ZXBASIC_USER_DATA
_tmpX:
	DEFB 00
_tmpY:
	DEFB 00
_nextMovement:
	DEFB 00
_pathMap:
	DEFW .LABEL.__LABEL96
_pathMap.__DATA__.__PTR__:
	DEFW _pathMap.__DATA__
_pathMap.__DATA__:
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
	DEFB 00h
.LABEL.__LABEL96:
	DEFW 0001h
	DEFW 000Ch
	DEFB 01h
.core.ZXBASIC_USER_DATA_END:
.core.__MAIN_PROGRAM__:
	call _InitializePathMap
	ld a, 2
	ld (_tmpX), a
	jp .LABEL.__LABEL0
.LABEL.__LABEL3:
	ld a, (_tmpX)
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld hl, 2
	push hl
	ld hl, _pathMap
	call .core.__ARRAY
	ld (hl), 0
	ld hl, _tmpX
	inc (hl)
.LABEL.__LABEL0:
	ld a, 9
	ld hl, (_tmpX - 1)
	cp h
	jp nc, .LABEL.__LABEL3
	ld a, 3
	ld (_tmpX), a
	jp .LABEL.__LABEL5
.LABEL.__LABEL8:
	ld a, (_tmpX)
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld hl, 4
	push hl
	ld hl, _pathMap
	call .core.__ARRAY
	ld (hl), 0
	ld hl, _tmpX
	inc (hl)
.LABEL.__LABEL5:
	ld a, 11
	ld hl, (_tmpX - 1)
	cp h
	jp nc, .LABEL.__LABEL8
	ld a, 2
	ld (_tmpX), a
	jp .LABEL.__LABEL10
.LABEL.__LABEL13:
	ld a, (_tmpX)
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld hl, 6
	push hl
	ld hl, _pathMap
	call .core.__ARRAY
	ld (hl), 0
	ld hl, _tmpX
	inc (hl)
.LABEL.__LABEL10:
	ld a, 6
	ld hl, (_tmpX - 1)
	cp h
	jp nc, .LABEL.__LABEL13
	ld a, 8
	ld (_tmpX), a
	jp .LABEL.__LABEL15
.LABEL.__LABEL18:
	ld a, (_tmpX)
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld hl, 6
	push hl
	ld hl, _pathMap
	call .core.__ARRAY
	ld (hl), 0
	ld hl, _tmpX
	inc (hl)
.LABEL.__LABEL15:
	ld a, 11
	ld hl, (_tmpX - 1)
	cp h
	jp nc, .LABEL.__LABEL18
	xor a
	ld (_pathMap.__DATA__ + 88), a
	ld (_pathMap.__DATA__ + 98), a
	ld a, 3
	ld (_tmpX), a
	jp .LABEL.__LABEL20
.LABEL.__LABEL23:
	ld a, (_tmpX)
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld hl, 9
	push hl
	ld hl, _pathMap
	call .core.__ARRAY
	ld (hl), 0
	ld hl, _tmpX
	inc (hl)
.LABEL.__LABEL20:
	ld a, 11
	ld hl, (_tmpX - 1)
	cp h
	jp nc, .LABEL.__LABEL23
	ld a, 1
	ld (_tmpX), a
	jp .LABEL.__LABEL25
.LABEL.__LABEL28:
	ld a, 1
	ld (_tmpY), a
	jp .LABEL.__LABEL30
.LABEL.__LABEL33:
	ld a, (_tmpX)
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld a, (_tmpY)
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld hl, _pathMap
	call .core.__ARRAY
	ld a, (hl)
	or a
	jp nz, .LABEL.__LABEL34
	ld a, (_tmpY)
	push af
	ld a, (_tmpX)
	call .core.PRINT_AT
	ld hl, .LABEL.__LABEL37
	xor a
	call .core.__PRINTSTR
	call .core.PRINT_EOL
.LABEL.__LABEL34:
	ld hl, _tmpY
	inc (hl)
.LABEL.__LABEL30:
	ld a, 12
	ld hl, (_tmpY - 1)
	cp h
	jp nc, .LABEL.__LABEL33
	ld hl, _tmpX
	inc (hl)
.LABEL.__LABEL25:
	ld a, 12
	ld hl, (_tmpX - 1)
	cp h
	jp nc, .LABEL.__LABEL28
	ld a, 10
	ld (_tmpX), a
	ld a, 11
	ld (_tmpY), a
	push af
	ld a, (_tmpX)
	call .core.PRINT_AT
	ld hl, .LABEL.__LABEL38
	xor a
	call .core.__PRINTSTR
	call .core.PRINT_EOL
	ld a, (_tmpY)
	push af
	ld a, (_tmpX)
	call _PathFind
	ld a, 2
	ld (_tmpX), a
	ld (_tmpY), a
	push af
	call .core.PRINT_AT
	ld hl, .LABEL.__LABEL39
	xor a
	call .core.__PRINTSTR
	call .core.PRINT_EOL
.LABEL.__LABEL40:
	ld a, (_tmpX)
	sub 10
	ld d, a
	ld a, (_tmpY)
	sub 11
	or d
	jp z, .LABEL.__LABEL41
	ld a, (_tmpY)
	push af
	ld a, (_tmpX)
	push af
	call _NextPathMovement
	ld (_nextMovement), a
	or a
	jp nz, .LABEL.__LABEL43
	xor a
	push af
	call .core.PRINT_AT
	ld hl, .LABEL.__LABEL44
	xor a
	call .core.__PRINTSTR
	call .core.PRINT_EOL
	ld a, 8
	call .core.__STOP
	ld bc, 0
.core.__END_PROGRAM:
	di
	ld hl, (.core.__CALL_BACK__)
	ld sp, hl
	exx
	pop hl
	pop iy
	pop ix
	exx
	ei
	ret
.LABEL.__LABEL43:
	ld a, (_nextMovement)
	dec a
	jp nz, .LABEL.__LABEL45
	xor a
	push af
	call .core.PRINT_AT
	ld hl, .LABEL.__LABEL47
	xor a
	call .core.__PRINTSTR
	call .core.PRINT_EOL
	ld hl, _tmpY
	dec (hl)
	jp .LABEL.__LABEL46
.LABEL.__LABEL45:
	ld a, (_nextMovement)
	sub 2
	jp nz, .LABEL.__LABEL48
	xor a
	push af
	call .core.PRINT_AT
	ld hl, .LABEL.__LABEL50
	xor a
	call .core.__PRINTSTR
	call .core.PRINT_EOL
	ld hl, _tmpY
	inc (hl)
	jp .LABEL.__LABEL46
.LABEL.__LABEL48:
	ld a, (_nextMovement)
	sub 3
	jp nz, .LABEL.__LABEL51
	xor a
	push af
	call .core.PRINT_AT
	ld hl, .LABEL.__LABEL53
	xor a
	call .core.__PRINTSTR
	call .core.PRINT_EOL
	ld hl, _tmpX
	dec (hl)
	jp .LABEL.__LABEL46
.LABEL.__LABEL51:
	ld a, (_nextMovement)
	sub 4
	jp nz, .LABEL.__LABEL46
	xor a
	push af
	call .core.PRINT_AT
	ld hl, .LABEL.__LABEL56
	xor a
	call .core.__PRINTSTR
	call .core.PRINT_EOL
	ld hl, _tmpX
	inc (hl)
.LABEL.__LABEL46:
	ld a, (_tmpY)
	push af
	ld a, (_tmpX)
	call .core.PRINT_AT
	ld hl, .LABEL.__LABEL39
	xor a
	call .core.__PRINTSTR
	call .core.PRINT_EOL
	ld hl, 1086
	push hl
	ld hl, 3
	call .core.__BEEPER
	ld hl, 30
	call .core.__PAUSE
	jp .LABEL.__LABEL40
.LABEL.__LABEL41:
	ld hl, 1086
	push hl
	ld hl, 3
	call .core.__BEEPER
	ld hl, 908
	push hl
	ld hl, 4
	call .core.__BEEPER
	ld hl, 715
	push hl
	ld hl, 5
	call .core.__BEEPER
	ld hl, 388
	push hl
	ld hl, 9
	call .core.__BEEPER
	xor a
	push af
	call .core.PRINT_AT
	ld hl, .LABEL.__LABEL57
	xor a
	call .core.__PRINTSTR
	call .core.PRINT_EOL
	ld bc, 0
	jp .core.__END_PROGRAM
_InitializePathMap:
	push ix
	ld ix, 0
	add ix, sp
	ld hl, 0
	push hl
	ld (ix-1), 1
	jp .LABEL.__LABEL58
.LABEL.__LABEL61:
	ld a, (ix-1)
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld hl, 0
	push hl
	ld hl, _pathMap
	call .core.__ARRAY
	ld (hl), 0
	ld a, (ix-1)
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld hl, 11
	push hl
	ld hl, _pathMap
	call .core.__ARRAY
	ld (hl), 0
	inc (ix-1)
.LABEL.__LABEL58:
	ld a, 12
	cp (ix-1)
	jp nc, .LABEL.__LABEL61
	ld (ix-2), 1
	jp .LABEL.__LABEL63
.LABEL.__LABEL66:
	ld hl, 0
	push hl
	ld a, (ix-2)
	ld l, a
	dec hl
	push hl
	ld hl, _pathMap
	call .core.__ARRAY
	ld (hl), 0
	ld hl, 11
	push hl
	ld a, (ix-2)
	ld l, a
	dec hl
	push hl
	ld hl, _pathMap
	call .core.__ARRAY
	ld (hl), 0
	inc (ix-2)
.LABEL.__LABEL63:
	ld a, 12
	cp (ix-2)
	jp nc, .LABEL.__LABEL66
	ld (ix-1), 2
	jp .LABEL.__LABEL68
.LABEL.__LABEL71:
	ld (ix-2), 2
	jp .LABEL.__LABEL73
.LABEL.__LABEL76:
	ld a, (ix-1)
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld a, (ix-2)
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld hl, _pathMap
	call .core.__ARRAY
	ld (hl), 255
	inc (ix-2)
.LABEL.__LABEL73:
	ld a, 11
	cp (ix-2)
	jp nc, .LABEL.__LABEL76
	inc (ix-1)
.LABEL.__LABEL68:
	ld a, 11
	cp (ix-1)
	jp nc, .LABEL.__LABEL71
_InitializePathMap__leave:
	ld sp, ix
	pop ix
	ret
_NextPathMovement:
	push ix
	ld ix, 0
	add ix, sp
	ld hl, 0
	push hl
	push hl
	inc sp
	ld a, (ix+5)
	ld l, a
	dec hl
	push hl
	ld a, (ix+7)
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld hl, _pathMap
	call .core.__ARRAY
	ld a, (hl)
	ld (ix-1), a
	sub 255
	jp nz, .LABEL.__LABEL79
	xor a
	jp _NextPathMovement__leave
.LABEL.__LABEL79:
	ld a, (ix+5)
	dec a
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld a, (ix+7)
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld hl, _pathMap
	call .core.__ARRAY
	ld a, (hl)
	ld (ix-2), a
	cp (ix-1)
	jp nc, .LABEL.__LABEL81
	or a
	jp z, .LABEL.__LABEL81
	ld a, (ix-2)
	ld (ix-1), a
	ld (ix-3), 3
.LABEL.__LABEL81:
	ld a, (ix+5)
	inc a
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld a, (ix+7)
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld hl, _pathMap
	call .core.__ARRAY
	ld a, (hl)
	ld (ix-2), a
	cp (ix-1)
	jp nc, .LABEL.__LABEL85
	or a
	jp z, .LABEL.__LABEL85
	ld a, (ix-2)
	ld (ix-1), a
	ld (ix-3), 4
.LABEL.__LABEL85:
	ld a, (ix+5)
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld a, (ix+7)
	dec a
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld hl, _pathMap
	call .core.__ARRAY
	ld a, (hl)
	ld (ix-2), a
	cp (ix-1)
	jp nc, .LABEL.__LABEL89
	or a
	jp z, .LABEL.__LABEL89
	ld a, (ix-2)
	ld (ix-1), a
	ld (ix-3), 1
.LABEL.__LABEL89:
	ld a, (ix+5)
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld a, (ix+7)
	inc a
	ld l, a
	ld h, 0
	dec hl
	push hl
	ld hl, _pathMap
	call .core.__ARRAY
	ld a, (hl)
	ld (ix-2), a
	cp (ix-1)
	jp nc, .LABEL.__LABEL93
	or a
	jp z, .LABEL.__LABEL93
	ld a, (ix-2)
	ld (ix-1), a
	ld (ix-3), 2
.LABEL.__LABEL93:
	ld a, (ix-3)
_NextPathMovement__leave:
	ld sp, ix
	pop ix
	exx
	pop hl
	pop bc
	ex (sp), hl
	exx
	ret
_PathFind:
#line 153 "C:/Users/geniw/source/repos/PathFindingLibrary/PathFindingLibrary/ZxBasicFiles/PathFinding.zxbas"
		PROC
		LOCAL pmap, worklist1, worklist2, save_sp
		LOCAL calc_distance, step_loop, skip_left, skip_right, skip_up, skip_down, swap_lists
		map_size	equ	12 * 12
		pmap        equ _pathMap.__DATA__
		di
		exx
		pop hl
		exx
		dec a
#line 177 "C:/Users/geniw/source/repos/PathFindingLibrary/PathFindingLibrary/ZxBasicFiles/PathFinding.zxbas"
		ld d, a
		pop af
		dec a
#line 182 "C:/Users/geniw/source/repos/PathFindingLibrary/PathFindingLibrary/ZxBasicFiles/PathFinding.zxbas"
		ld e, a
		exx
		push hl
		exx
calc_distance:
		ld  hl, 0
		ld	b,e
		ld	e,d
		ld	d,h
		ld  a, b
		and a
		jp z, no_mul
		push de
		ld de, 12
mul_loop:
		add hl, de
		djnz mul_loop
		pop de
no_mul:
		add	hl,de
		ld	de,pmap
		add	hl,de
		ld	(save_sp),sp
		ld	sp,worklist1+2
		xor	a
		ld	(worklist1+3),a
		ld	de,worklist2
		ld	a,255-253
		ld	(hl),254-253
		step_loop
		dec	hl
		cp	(hl)
		jr	nc,skip_left
		ld	(hl),a
		ex	de,hl
		ld	(hl),e
		inc	hl
		ld	(hl),d
		inc	hl
		ex	de,hl
		skip_left
		inc	hl
		inc	hl
		cp	(hl)
		jr	nc,skip_right
		ld	(hl),a
		ex	de,hl
		ld	(hl),e
		inc	hl
		ld	(hl),d
		inc	hl
		ex	de,hl
		skip_right
		ld	bc,-12-1
		add	hl,bc
		cp	(hl)
		jr	nc,skip_up
		ld	(hl),a
		ex	de,hl
		ld	(hl),e
		inc	hl
		ld	(hl),d
		inc	hl
		ex	de,hl
		skip_up
		ld	bc,12*2
		add	hl,bc
		cp	(hl)
		jr	nc,skip_down
		ld	(hl),a
		ex	de,hl
		ld	(hl),e
		inc	hl
		ld	(hl),d
		inc	hl
		ex	de,hl
		skip_down
		pop	hl
		inc	h
		dec	h
		jr	nz,step_loop
		ex	de,hl
		inc	hl
		ld	(hl),b
		inc	a
		ld	de,worklist2
		ld	hl,worklist1
		bit	0,a
		jr	z,swap_lists
		ex	de,hl
		swap_lists	ld	sp,hl
		pop	hl
		inc	h
		dec	h
		jr	nz,step_loop
		ld	sp,(save_sp)
		jp end_path_proc
worklist1:	ds	2*4*12
worklist2:	ds	2*4*12
		save_sp		ds	2
end_path_proc:
		ei
		ENDP
#line 341 "C:/Users/geniw/source/repos/PathFindingLibrary/PathFindingLibrary/ZxBasicFiles/PathFinding.zxbas"
_PathFind__leave:
	ret
.LABEL.__LABEL37:
	DEFW 0001h
	DEFB 23h
.LABEL.__LABEL38:
	DEFW 0001h
	DEFB 40h
.LABEL.__LABEL39:
	DEFW 0001h
	DEFB 4Fh
.LABEL.__LABEL44:
	DEFW 0018h
	DEFB 54h
	DEFB 41h
	DEFB 52h
	DEFB 47h
	DEFB 45h
	DEFB 54h
	DEFB 20h
	DEFB 55h
	DEFB 4Eh
	DEFB 52h
	DEFB 45h
	DEFB 41h
	DEFB 43h
	DEFB 48h
	DEFB 41h
	DEFB 42h
	DEFB 4Ch
	DEFB 45h
	DEFB 21h
	DEFB 21h
	DEFB 21h
	DEFB 21h
	DEFB 21h
	DEFB 21h
.LABEL.__LABEL47:
	DEFW 0006h
	DEFB 55h
	DEFB 50h
	DEFB 20h
	DEFB 20h
	DEFB 20h
	DEFB 20h
.LABEL.__LABEL50:
	DEFW 0006h
	DEFB 44h
	DEFB 4Fh
	DEFB 57h
	DEFB 4Eh
	DEFB 20h
	DEFB 20h
.LABEL.__LABEL53:
	DEFW 0006h
	DEFB 4Ch
	DEFB 45h
	DEFB 46h
	DEFB 54h
	DEFB 20h
	DEFB 20h
.LABEL.__LABEL56:
	DEFW 0006h
	DEFB 52h
	DEFB 49h
	DEFB 47h
	DEFB 48h
	DEFB 54h
	DEFB 20h
.LABEL.__LABEL57:
	DEFW 000Ah
	DEFB 4Fh
	DEFB 4Eh
	DEFB 20h
	DEFB 54h
	DEFB 41h
	DEFB 52h
	DEFB 47h
	DEFB 45h
	DEFB 54h
	DEFB 21h
	;; --- end of user code ---
#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/array.asm"
; vim: ts=4:et:sw=4:
	; Copyleft (K) by Jose M. Rodriguez de la Rosa
	;  (a.k.a. Boriel)
;  http://www.boriel.com
	; -------------------------------------------------------------------
	; Simple array Index routine
	; Number of total indexes dimensions - 1 at beginning of memory
	; HL = Start of array memory (First two bytes contains N-1 dimensions)
	; Dimension values on the stack, (top of the stack, highest dimension)
	; E.g. A(2, 4) -> PUSH <4>; PUSH <2>

	; For any array of N dimension A(aN-1, ..., a1, a0)
	; and dimensions D[bN-1, ..., b1, b0], the offset is calculated as
	; O = [a0 + b0 * (a1 + b1 * (a2 + ... bN-2(aN-1)))]
; What I will do here is to calculate the following sequence:
	; ((aN-1 * bN-2) + aN-2) * bN-3 + ...


#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/mul16.asm"

.core.__MUL16:	; Mutiplies HL with the last value stored into de stack
	    ; Works for both signed and unsigned

	    PROC

	    LOCAL __MUL16LOOP
	    LOCAL __MUL16NOADD

	    ex de, hl
	    pop hl		; Return address
	    ex (sp), hl ; CALLEE caller convention

.core.__MUL16_FAST:
	    ld b, 16
	    ld a, h
	    ld c, l
	    ld hl, 0

__MUL16LOOP:
	    add hl, hl  ; hl << 1
	    sla c
	    rla         ; a,c << 1
	    jp nc, __MUL16NOADD
	    add hl, de

__MUL16NOADD:
	    djnz __MUL16LOOP

	    ret	; Result in hl (16 lower bits)

	    ENDP


#line 20 "C:/zxbasic/src/arch/zx48k/library-asm/array.asm"

#line 24 "C:/zxbasic/src/arch/zx48k/library-asm/array.asm"


.core.__ARRAY_PTR:   ;; computes an array offset from a pointer
	    ld c, (hl)
	    inc hl
	    ld h, (hl)
	    ld l, c

.core.__ARRAY:
	    PROC

	    LOCAL LOOP
	    LOCAL ARRAY_END
	    LOCAL RET_ADDRESS ; Stores return address
	    LOCAL TMP_ARR_PTR ; Stores pointer temporarily

	    ld e, (hl)
	    inc hl
	    ld d, (hl)
	    inc hl
	    ld (TMP_ARR_PTR), hl
	    ex de, hl
	    ex (sp), hl	; Return address in HL, array address in the stack
	    ld (RET_ADDRESS + 1), hl ; Stores it for later

	    exx
	    pop hl		; Will use H'L' as the pointer
	    ld c, (hl)	; Loads Number of dimensions from (hl)
	    inc hl
	    ld b, (hl)
	    inc hl		; Ready
	    exx

	    ld hl, 0	; HL = Offset "accumulator"

LOOP:
#line 64 "C:/zxbasic/src/arch/zx48k/library-asm/array.asm"
	    pop bc		; Get next index (Ai) from the stack

#line 74 "C:/zxbasic/src/arch/zx48k/library-asm/array.asm"

	    add hl, bc	; Adds current index

	    exx			; Checks if B'C' = 0
	    ld a, b		; Which means we must exit (last element is not multiplied by anything)
	    or c
	    jr z, ARRAY_END		; if B'Ci == 0 we are done

	    ld e, (hl)			; Loads next dimension into D'E'
	    inc hl
	    ld d, (hl)
	    inc hl
	    push de
	    dec bc				; Decrements loop counter
	    exx
	    pop de				; DE = Max bound Number (i-th dimension)

	    call __FNMUL
	    jp LOOP

ARRAY_END:
	    ld a, (hl)
	    exx

#line 103 "C:/zxbasic/src/arch/zx48k/library-asm/array.asm"
	    LOCAL ARRAY_SIZE_LOOP

	    ex de, hl
	    ld hl, 0
	    ld b, a
ARRAY_SIZE_LOOP:
	    add hl, de
	    djnz ARRAY_SIZE_LOOP

#line 113 "C:/zxbasic/src/arch/zx48k/library-asm/array.asm"

	    ex de, hl
	    ld hl, (TMP_ARR_PTR)
	    ld a, (hl)
	    inc hl
	    ld h, (hl)
	    ld l, a
	    add hl, de  ; Adds element start

RET_ADDRESS:
	    jp 0

	    ;; Performs a faster multiply for little 16bit numbs
	    LOCAL __FNMUL, __FNMUL2

__FNMUL:
	    xor a
	    or h
	    jp nz, .core.__MUL16_FAST
	    or l
	    ret z

	    cp 33
	    jp nc, .core.__MUL16_FAST

	    ld b, l
	    ld l, h  ; HL = 0

__FNMUL2:
	    add hl, de
	    djnz __FNMUL2
	    ret

TMP_ARR_PTR:
	    DW 0  ; temporary storage for pointer to tables

	    ENDP


#line 425 "C:/Users/geniw/source/repos/PathFindingLibrary/PathFindingLibrary/ZxBasicFiles/PathFinding.zxbas"
#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/beeper.asm"
; vim:ts=4:et:sw=4:
	; This is a fast beep routine, but needs parameters
	; codified in a different way.
; See http://www.wearmouth.demon.co.uk/zx82.htm#L03F8

	; Needs pitch on top of the stack
	; HL = duration


.core.__BEEPER:
	    ex de, hl
	    pop hl
	    ex (sp), hl ; CALLEE
	    push ix     ; BEEPER changes IX
	    call 03B5h
	    pop ix
	    ret



#line 426 "C:/Users/geniw/source/repos/PathFindingLibrary/PathFindingLibrary/ZxBasicFiles/PathFinding.zxbas"
#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/error.asm"
	; Simple error control routines
; vim:ts=4:et:


	ERR_NR    EQU    23610    ; Error code system variable


	; Error code definitions (as in ZX spectrum manual)

; Set error code with:
	;    ld a, ERROR_CODE
	;    ld (ERR_NR), a


	ERROR_Ok                EQU    -1
	ERROR_SubscriptWrong    EQU     2
	ERROR_OutOfMemory       EQU     3
	ERROR_OutOfScreen       EQU     4
	ERROR_NumberTooBig      EQU     5
	ERROR_InvalidArg        EQU     9
	ERROR_IntOutOfRange     EQU    10
	ERROR_NonsenseInBasic   EQU    11
	ERROR_InvalidFileName   EQU    14
	ERROR_InvalidColour     EQU    19
	ERROR_BreakIntoProgram  EQU    20
	ERROR_TapeLoadingErr    EQU    26


	; Raises error using RST #8
.core.__ERROR:
	    ld (.core.__ERROR_CODE), a
	    rst 8
.core.__ERROR_CODE:
	    nop
	    ret

	; Sets the error system variable, but keeps running.
	; Usually this instruction if followed by the END intermediate instruction.
.core.__STOP:
	    ld (ERR_NR), a
	    ret

#line 427 "C:/Users/geniw/source/repos/PathFindingLibrary/PathFindingLibrary/ZxBasicFiles/PathFinding.zxbas"
#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/pause.asm"
	; The PAUSE statement (Calling the ROM)


.core.__PAUSE:
	    ld b, h
	    ld c, l
	    jp 1F3Dh  ; PAUSE_1

#line 428 "C:/Users/geniw/source/repos/PathFindingLibrary/PathFindingLibrary/ZxBasicFiles/PathFinding.zxbas"
#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"
; vim:ts=4:sw=4:et:
; vim:ts=4:sw=4:et:
	; PRINT command routine
	; Does not print attribute. Use PRINT_STR or PRINT_NUM for that

#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/sposn.asm"
	; Printing positioning library.

	    PROC
	    LOCAL ECHO_E

.core.__LOAD_S_POSN:		; Loads into DE current ROW, COL print position from .core.S_POSN mem var.
	    ld de, (.core.S_POSN)
	    ld hl, (.core.MAXX)
	    or a
	    sbc hl, de
	    ex de, hl
	    ret


.core.__SAVE_S_POSN:		; Saves ROW, COL from DE into .core.S_POSN mem var.
	    ld hl, (.core.MAXX)
	    or a
	    sbc hl, de
	    ld (.core.S_POSN), hl ; saves it again
	    ret


	ECHO_E	EQU 23682
	.core.MAXX	EQU ECHO_E   ; Max X position + 1
	.core.MAXY	EQU .core.MAXX + 1 ; Max Y position + 1

	.core.S_POSN	EQU 23688
	.core.POSX	EQU .core.S_POSN		; Current POS X
	.core.POSY	EQU .core.S_POSN + 1	; Current POS Y

	    ENDP


#line 7 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"
#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/cls.asm"
	; JUMPS directly to spectrum CLS
	; This routine does not clear lower screen

	;CLS	EQU	0DAFh

	; Our faster implementation




.core.CLS:
	    PROC

	    LOCAL COORDS
	    LOCAL __CLS_SCR
	    LOCAL ATTR_P
	    LOCAL SCREEN

	    ld hl, 0
	    ld (COORDS), hl
	    ld hl, 1821h
	    ld (.core.S_POSN), hl
__CLS_SCR:
	    ld hl, SCREEN
	    ld (hl), 0
	    ld d, h
	    ld e, l
	    inc de
	    ld bc, 6144
	    ldir

	    ; Now clear attributes

	    ld a, (ATTR_P)
	    ld (hl), a
	    ld bc, 767
	    ldir
	    ret

	COORDS	EQU	23677
	SCREEN	EQU 16384 ; Default start of the screen (can be changed)
	ATTR_P	EQU 23693
	;you can poke (SCREEN_SCRADDR) to change .core.CLS, DRAW & PRINTing address

	.core.SCREEN_ADDR EQU (__CLS_SCR + 1) ; Address used by print and other screen routines
	    ; to get the start of the screen
	    ENDP


#line 8 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"
#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/in_screen.asm"




.core.__IN_SCREEN:
	    ; Returns NO carry if current coords (D, E)
	    ; are OUT of the screen limits (.core.MAXX, .core.MAXY)

	    PROC
	    LOCAL __IN_SCREEN_ERR

	    ld hl, .core.MAXX
	    ld a, e
	    cp (hl)
	    jr nc, __IN_SCREEN_ERR	; Do nothing and return if out of range

	    ld a, d
	    inc hl
	    cp (hl)
	    ;; jr nc, __IN_SCREEN_ERR	; Do nothing and return if out of range
	    ;; ret
	    ret c                       ; Return if carry (OK)

__IN_SCREEN_ERR:
.core.__OUT_OF_SCREEN_ERR:
	    ; Jumps here if out of screen
	    ld a, ERROR_OutOfScreen
	    jp .core.__STOP   ; Saves error code and exits

	    ENDP

#line 9 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"
#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/table_jump.asm"


.core.JUMP_HL_PLUS_2A: ; Does JP (HL + A*2) Modifies DE. Modifies A
	    add a, a

.core.JUMP_HL_PLUS_A:	 ; Does JP (HL + A) Modifies DE
	    ld e, a
	    ld d, 0

.core.JUMP_HL_PLUS_DE: ; Does JP (HL + DE)
	    add hl, de
	    ld e, (hl)
	    inc hl
	    ld d, (hl)
	    ex de, hl
.core.CALL_HL:
	    jp (hl)


#line 10 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"
#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/ink.asm"
	; Sets ink color in ATTR_P permanently
; Parameter: Paper color in A register

#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/const.asm"
	; Global constants


	.core.P_FLAG	EQU 23697
	.core.FLAGS2	EQU 23681
	.core.ATTR_P	EQU 23693	; permanet ATTRIBUTES
	.core.ATTR_T	EQU 23695	; temporary ATTRIBUTES
	.core.CHARS	EQU 23606 ; Pointer to ROM/RAM Charset
	.core.UDG	EQU 23675 ; Pointer to .core.UDG Charset
	.core.MEM0	EQU 5C92h ; Temporary memory buffer used by ROM chars


#line 5 "C:/zxbasic/src/arch/zx48k/library-asm/ink.asm"


.core.INK:
	    PROC
	    LOCAL __SET_INK
	    LOCAL __SET_INK2

	    ld de, .core.ATTR_P

__SET_INK:
	    cp 8
	    jr nz, __SET_INK2

	    inc de ; Points DE to MASK_T or MASK_P
	    ld a, (de)
	    or 7 ; Set bits 0,1,2 to enable transparency
	    ld (de), a
	    ret

__SET_INK2:
	    ; Another entry. This will set the ink color at location pointer by DE
	    and 7	; # Gets color mod 8
	    ld b, a	; Saves the color
	    ld a, (de)
	    and 0F8h ; Clears previous value
	    or b
	    ld (de), a
	    inc de ; Points DE to MASK_T or MASK_P
	    ld a, (de)
	    and 0F8h ; Reset bits 0,1,2 sign to disable transparency
	    ld (de), a ; Store new attr
	    ret

	; Sets the .core.INK color passed in A register in the .core.ATTR_T variable
.core.INK_TMP:
	    ld de, .core.ATTR_T
	    jp __SET_INK

	    ENDP


#line 11 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"
#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/paper.asm"
	; Sets paper color in ATTR_P permanently
; Parameter: Paper color in A register




.core.PAPER:
	    PROC
	    LOCAL __SET_PAPER
	    LOCAL __SET_PAPER2

	    ld de, .core.ATTR_P

__SET_PAPER:
	    cp 8
	    jr nz, __SET_PAPER2
	    inc de
	    ld a, (de)
	    or 038h
	    ld (de), a
	    ret

	    ; Another entry. This will set the paper color at location pointer by DE
__SET_PAPER2:
	    and 7	; # Remove
	    rlca
	    rlca
	    rlca		; a *= 8

	    ld b, a	; Saves the color
	    ld a, (de)
	    and 0C7h ; Clears previous value
	    or b
	    ld (de), a
	    inc de ; Points to MASK_T or MASK_P accordingly
	    ld a, (de)
	    and 0C7h  ; Resets bits 3,4,5
	    ld (de), a
	    ret


	; Sets the .core.PAPER color passed in A register in the .core.ATTR_T variable
.core.PAPER_TMP:
	    ld de, .core.ATTR_T
	    jp __SET_PAPER
	    ENDP


#line 12 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"
#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/flash.asm"
	; Sets flash flag in ATTR_P permanently
; Parameter: Paper color in A register




.core.FLASH:
	    ld hl, .core.ATTR_P

	    PROC
	    LOCAL IS_TR
	    LOCAL IS_ZERO

.core.__SET_FLASH:
	    ; Another entry. This will set the flash flag at location pointer by DE
	    cp 8
	    jr z, IS_TR

	    ; # Convert to 0/1
	    or a
	    jr z, IS_ZERO
	    ld a, 0x80

IS_ZERO:
	    ld b, a	; Saves the color
	    ld a, (hl)
	    and 07Fh ; Clears previous value
	    or b
	    ld (hl), a
	    inc hl
	    res 7, (hl)  ;Reset bit 7 to disable transparency
	    ret

IS_TR:  ; transparent
	    inc hl ; Points DE to MASK_T or MASK_P
	    set 7, (hl)  ;Set bit 7 to enable transparency
	    ret

	; Sets the .core.FLASH flag passed in A register in the .core.ATTR_T variable
.core.FLASH_TMP:
	    ld hl, .core.ATTR_T
	    jr .core.__SET_FLASH
	    ENDP


#line 13 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"
#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/bright.asm"
	; Sets bright flag in ATTR_P permanently
; Parameter: Paper color in A register




.core.BRIGHT:
	    ld hl, .core.ATTR_P

	    PROC
	    LOCAL IS_TR
	    LOCAL IS_ZERO

.core.__SET_BRIGHT:
	    ; Another entry. This will set the bright flag at location pointer by DE
	    cp 8
	    jr z, IS_TR

	    ; # Convert to 0/1
	    or a
	    jr z, IS_ZERO
	    ld a, 0x40

IS_ZERO:
	    ld b, a	; Saves the color
	    ld a, (hl)
	    and 0BFh ; Clears previous value
	    or b
	    ld (hl), a
	    inc hl
	    res 6, (hl)  ;Reset bit 6 to disable transparency
	    ret

IS_TR:  ; transparent
	    inc hl ; Points DE to MASK_T or MASK_P
	    set 6, (hl)  ;Set bit 6 to enable transparency
	    ret

	; Sets the .core.BRIGHT flag passed in A register in the .core.ATTR_T variable
.core.BRIGHT_TMP:
	    ld hl, .core.ATTR_T
	    jr .core.__SET_BRIGHT
	    ENDP

#line 14 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"
#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/over.asm"
	; Sets OVER flag in P_FLAG permanently
; Parameter: OVER flag in bit 0 of A register
#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/copy_attr.asm"


#line 4 "C:/zxbasic/src/arch/zx48k/library-asm/copy_attr.asm"




.core.COPY_ATTR:
	    ; Just copies current permanent attribs into temporal attribs
	    ; and sets print mode
	    PROC

	    LOCAL INVERSE1
	    LOCAL __REFRESH_TMP

	INVERSE1 EQU 02Fh

	    ld hl, (.core.ATTR_P)
	    ld (.core.ATTR_T), hl

	    ld hl, .core.FLAGS2
	    call __REFRESH_TMP

	    ld hl, .core.P_FLAG
	    call __REFRESH_TMP


.core.__SET_ATTR_MODE:		; Another entry to set print modes. A contains (.core.P_FLAG)


	    LOCAL TABLE
	    LOCAL CONT2

	    rra					; Over bit to carry
	    ld a, (.core.FLAGS2)
	    rla					; Over bit in bit 1, Over2 bit in bit 2
	    and 3				; Only bit 0 and 1 (.core.OVER flag)

	    ld c, a
	    ld b, 0

	    ld hl, TABLE
	    add hl, bc
	    ld a, (hl)
	    ld (.core.PRINT_MODE), a

	    ld hl, (.core.P_FLAG)
	    xor a			; NOP -> INVERSE0
	    bit 2, l
	    jr z, CONT2
	    ld a, INVERSE1 	; CPL -> INVERSE1

CONT2:
	    ld (.core.INVERSE_MODE), a
	    ret

TABLE:
	    nop				; NORMAL MODE
	    xor (hl)		; .core.OVER 1 MODE
	    and (hl)		; .core.OVER 2 MODE
	    or  (hl)		; .core.OVER 3 MODE

#line 67 "C:/zxbasic/src/arch/zx48k/library-asm/copy_attr.asm"

__REFRESH_TMP:
	    ld a, (hl)
	    and 10101010b
	    ld c, a
	    rra
	    or c
	    ld (hl), a
	    ret

	    ENDP


#line 4 "C:/zxbasic/src/arch/zx48k/library-asm/over.asm"



.core.OVER:
	    PROC

	    ld c, a ; saves it for later
	    and 2
	    ld hl, .core.FLAGS2
	    res 1, (HL)
	    or (hl)
	    ld (hl), a

	    ld a, c	; Recovers previous value
	    and 1	; # Convert to 0/1
	    add a, a; # Shift left 1 bit for permanent

	    ld hl, .core.P_FLAG
	    res 1, (hl)
	    or (hl)
	    ld (hl), a
	    ret

	; Sets .core.OVER flag in .core.P_FLAG temporarily
.core.OVER_TMP:
	    ld c, a ; saves it for later
	    and 2	; gets bit 1; clears carry
	    rra
	    ld hl, .core.FLAGS2
	    res 0, (hl)
	    or (hl)
	    ld (hl), a

	    ld a, c	; Recovers previous value
	    and 1
	    ld hl, .core.P_FLAG
	    res 0, (hl)
	    or (hl)
	    ld (hl), a
	    jp .core.__SET_ATTR_MODE

	    ENDP


#line 15 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"
#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/inverse.asm"
	; Sets INVERSE flag in P_FLAG permanently
; Parameter: INVERSE flag in bit 0 of A register




.core.INVERSE:
	    PROC

	    and 1	; # Convert to 0/1
	    add a, a; # Shift left 3 bits for permanent
	    add a, a
	    add a, a
	    ld hl, .core.P_FLAG
	    res 3, (hl)
	    or (hl)
	    ld (hl), a
	    ret

	; Sets .core.INVERSE flag in .core.P_FLAG temporarily
.core.INVERSE_TMP:
	    and 1
	    add a, a
	    add a, a; # Shift left 2 bits for temporary
	    ld hl, .core.P_FLAG
	    res 2, (hl)
	    or (hl)
	    ld (hl), a
	    jp .core.__SET_ATTR_MODE

	    ENDP


#line 16 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"
#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/bold.asm"
	; Sets BOLD flag in P_FLAG permanently
; Parameter: BOLD flag in bit 0 of A register



.core.BOLD:
	    PROC

	    and 1
	    rlca
	    rlca
	    rlca
	    ld hl, .core.FLAGS2
	    res 3, (HL)
	    or (hl)
	    ld (hl), a
	    ret

	; Sets .core.BOLD flag in .core.P_FLAG temporarily
.core.BOLD_TMP:
	    and 1
	    rlca
	    rlca
	    ld hl, .core.FLAGS2
	    res 2, (hl)
	    or (hl)
	    ld (hl), a
	    ret

	    ENDP


#line 17 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"
#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/italic.asm"
	; Sets ITALIC flag in P_FLAG permanently
; Parameter: ITALIC flag in bit 0 of A register



.core.ITALIC:
	    PROC

	    and 1
	    rrca
	    rrca
	    rrca
	    ld hl, .core.FLAGS2
	    res 5, (HL)
	    or (hl)
	    ld (hl), a
	    ret

	; Sets .core.ITALIC flag in .core.P_FLAG temporarily
.core.ITALIC_TMP:
	    and 1
	    rrca
	    rrca
	    rrca
	    rrca
	    ld hl, .core.FLAGS2
	    res 4, (hl)
	    or (hl)
	    ld (hl), a
	    ret

	    ENDP


#line 18 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"

#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/attr.asm"
	; Attribute routines
; vim:ts=4:et:sw:








.core.__ATTR_ADDR:
	    ; calc start address in DE (as (32 * d) + e)
    ; Contributed by Santiago Romero at http://www.speccy.org
	    ld h, 0                     ;  7 T-States
	    ld a, d                     ;  4 T-States
	    add a, a     ; a * 2        ;  4 T-States
	    add a, a     ; a * 4        ;  4 T-States
	    ld l, a      ; HL = A * 4   ;  4 T-States

	    add hl, hl   ; HL = A * 8   ; 15 T-States
	    add hl, hl   ; HL = A * 16  ; 15 T-States
	    add hl, hl   ; HL = A * 32  ; 15 T-States

    ld d, 18h ; DE = 6144 + E. Note: 6144 is the screen size (before attr zone)
	    add hl, de

	    ld de, (.core.SCREEN_ADDR)    ; Adds the screen address
	    add hl, de

	    ; Return current screen address in HL
	    ret


	; Sets the attribute at a given screen coordinate (D, E).
	; The attribute is taken from the .core.ATTR_T memory variable
	; Used by PRINT routines
.core.SET_ATTR:

	    ; Checks for valid coords
	    call .core.__IN_SCREEN
	    ret nc

.core.__SET_ATTR:
	    ; Internal __FASTCALL__ Entry used by printing routines
	    PROC

	    call .core.__ATTR_ADDR

.core.__SET_ATTR2:  ; Sets attr from .core.ATTR_T to (HL) which points to the scr address
	    ld de, (.core.ATTR_T)    ; E = .core.ATTR_T, D = MASK_T

	    ld a, d
	    and (hl)
	    ld c, a    ; C = current screen color, masked

	    ld a, d
	    cpl        ; Negate mask
	    and e    ; Mask current attributes
	    or c    ; Mix them
	    ld (hl), a ; Store result in screen

	    ret

	    ENDP


	; Sets the attribute at a given screen pixel address in hl
	; HL contains the address in RAM for a given pixel (not a coordinate)
.core.SET_PIXEL_ADDR_ATTR:
	    ;; gets ATTR position with offset given in .core.SCREEN_ADDR
	    ld a, h
	    rrca
	    rrca
	    rrca
	    and 3
	    or 18h
	    ld h, a
	    ld de, (.core.SCREEN_ADDR)
	    add hl, de  ;; Final screen addr
	    jp .core.__SET_ATTR2

#line 20 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"

	; Putting a comment starting with @INIT <address>
	; will make the compiler to add a CALL to <address>
	; It is useful for initialization routines.



.core.__PRINT_INIT: ; To be called before program starts (initializes library)
	    PROC

	    ld hl, __PRINT_START
	    ld (.core.PRINT_JUMP_STATE), hl

	    ld hl, 1821h
	    ld (.core.MAXX), hl  ; Sets current maxX and maxY

	    xor a
	    ld (.core.FLAGS2), a

	    ret


.core.__PRINTCHAR: ; Print character store in accumulator (A register)
	    ; Modifies H'L', B'C', A'F', D'E', A

	    LOCAL PO_GR_1

	    LOCAL __PRCHAR
	    LOCAL __PRINT_CONT
	    LOCAL __PRINT_CONT2
	    LOCAL __PRINT_JUMP
	    LOCAL __SRCADDR
	    LOCAL __PRINT_UDG
	    LOCAL __PRGRAPH
	    LOCAL __PRINT_START
	    LOCAL __ROM_SCROLL_SCR
	    LOCAL __TVFLAGS

	    __ROM_SCROLL_SCR EQU 0DFEh
	    __TVFLAGS EQU 5C3Ch

	.core.PRINT_JUMP_STATE EQU __PRINT_JUMP + 1

__PRINT_JUMP:
	    jp __PRINT_START    ; Where to jump. If we print 22 (AT), next two calls jumps to AT1 and AT2 respectively


	    LOCAL __SCROLL
__SCROLL:  ; Scroll?
	    ld hl, __TVFLAGS
	    bit 1, (hl)
	    ret z
	    call __ROM_SCROLL_SCR
	    ld hl, __TVFLAGS
	    res 1, (hl)
	    ret
#line 78 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"

__PRINT_START:
	    cp ' '
	    jp c, .core.__PRINT_SPECIAL    ; Characters below ' ' are special ones

	    exx               ; Switch to alternative registers
	    ex af, af'        ; Saves a value (char to print) for later


	    call __SCROLL
#line 89 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"
	    call .core.__LOAD_S_POSN

	; At this point we have the new coord
	    ld hl, (.core.SCREEN_ADDR)

	    ld a, d
	    ld c, a     ; Saves it for later

	    and 0F8h    ; Masks 3 lower bit ; zy
	    ld d, a

	    ld a, c     ; Recovers it
	    and 07h     ; MOD 7 ; y1
	    rrca
	    rrca
	    rrca

	    or e
	    ld e, a
	    add hl, de    ; HL = Screen address + DE
	    ex de, hl     ; DE = Screen address

	    ex af, af'

	    cp 80h    ; Is it an .core.UDG or a ?
	    jp c, __SRCADDR

	    cp 90h
	    jp nc, __PRINT_UDG

	    ; Print a 8 bit pattern (80h to 8Fh)

	    ld b, a
	    call PO_GR_1 ; This ROM routine will generate the bit pattern at .core.MEM0
	    ld hl, .core.MEM0
	    jp __PRGRAPH

	PO_GR_1 EQU 0B38h

__PRINT_UDG:
	    sub 90h ; Sub ASC code
	    ld bc, (.core.UDG)
	    jp .core.__PRGRAPH0

	.core.__SOURCEADDR EQU (__SRCADDR + 1)    ; Address of the pointer to chars source
__SRCADDR:
	    ld bc, (.core.CHARS)

.core.__PRGRAPH0:
    add a, a   ; A = a * 2 (since a < 80h) ; Thanks to Metalbrain at http://foro.speccy.org
	    ld l, a
	    ld h, 0    ; HL = a * 2 (accumulator)
	    add hl, hl
	    add hl, hl ; HL = a * 8
	    add hl, bc ; HL = .core.CHARS address

__PRGRAPH:
	    ex de, hl  ; HL = Write Address, DE = .core.CHARS address
	    bit 2, (iy + $47)
	    call nz, __BOLD
	    bit 4, (iy + $47)
	    call nz, __ITALIC
	    ld b, 8 ; 8 bytes per char
__PRCHAR:
	    ld a, (de) ; DE *must* be ALWAYS source, and HL destiny

.core.PRINT_MODE:     ; Which operation is used to write on the screen
    ; Set it with:
	    ; LD A, <OPERATION>
	    ; LD (.core.PRINT_MODE), A
	    ;
    ; Available opertions:
    ; NORMAL : 0h  --> NOP         ; .core.OVER 0
    ; XOR    : AEh --> XOR (HL)    ; .core.OVER 1
    ; OR     : B6h --> OR (HL)     ; PUTSPRITE
    ; AND    : A6h --> AND (HL)    ; PUTMASK
	    nop     ;

.core.INVERSE_MODE:   ; 00 -> NOP -> .core.INVERSE 0
	    nop     ; 2F -> CPL -> .core.INVERSE 1

	    ld (hl), a

	    inc de
	    inc h     ; Next line
	    djnz __PRCHAR

	    call .core.__LOAD_S_POSN
	    push de
	    call .core.__SET_ATTR
	    pop de
	    inc e            ; COL = COL + 1
	    ld hl, (.core.MAXX)
	    ld a, e
	    dec l            ; l = .core.MAXX
	    cp l             ; Lower than max?
	    jp nc, __PRINT_EOL1

__PRINT_CONT:
	    call .core.__SAVE_S_POSN

__PRINT_CONT2:
	    exx
	    ret

	; ------------- SPECIAL .core.CHARS (< 32) -----------------

.core.__PRINT_SPECIAL:    ; Jumps here if it is a special char
	    exx
	    ld hl, __PRINT_TABLE
	    jp .core.JUMP_HL_PLUS_2A


.core.PRINT_EOL:        ; Called WHENEVER there is no ";" at end of PRINT sentence
	    exx

.core.__PRINT_0Dh:        ; Called WHEN printing CHR$(13)

	    call __SCROLL
#line 209 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"
	    call .core.__LOAD_S_POSN

__PRINT_EOL1:        ; Another entry called from PRINT when next line required
	    ld e, 0

__PRINT_EOL2:
	    ld a, d
	    inc a

.core.__PRINT_AT1_END:
	    ld hl, (.core.MAXY)
	    cp l
	    jr c, .core.__PRINT_EOL_END    ; Carry if (.core.MAXY) < d

	    ld hl, __TVFLAGS
	    set 1, (hl)
	    dec a
#line 229 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"

.core.__PRINT_EOL_END:
	    ld d, a

__PRINT_AT2_END:
	    call .core.__SAVE_S_POSN
	    exx
	    ret

__PRINT_COM:
	    exx
	    push hl
	    push de
	    push bc
	    call .core.PRINT_COMMA
	    pop bc
	    pop de
	    pop hl
	    ret

__PRINT_TAB:
	    ld hl, __PRINT_TAB1
	    jr __PRINT_SET_STATE

__PRINT_TAB1:
	    ld (.core.MEM0), a
	    exx
	    ld hl, __PRINT_TAB2
	    jr __PRINT_SET_STATE

__PRINT_TAB2:
	    ld a, (.core.MEM0)        ; Load tab code (ignore the current one)
	    push hl
	    push de
	    push bc
	    ld hl, __PRINT_START
	    ld (.core.PRINT_JUMP_STATE), hl
	    call .core.PRINT_TAB
	    pop bc
	    pop de
	    pop hl
	    ret

.core.__PRINT_NOP:
.core.__PRINT_RESTART:
	    ld hl, __PRINT_START
	    jr __PRINT_SET_STATE

.core.__PRINT_AT:
	    ld hl, __PRINT_AT1

__PRINT_SET_STATE:
	    ld (.core.PRINT_JUMP_STATE), hl    ; Saves next entry call
	    exx
	    ret

__PRINT_AT1:    ; Jumps here if waiting for 1st parameter
	    exx
	    ld hl, __PRINT_AT2
	    ld (.core.PRINT_JUMP_STATE), hl    ; Saves next entry call
	    call .core.__LOAD_S_POSN
	    jr .core.__PRINT_AT1_END

__PRINT_AT2:
	    exx
	    ld hl, __PRINT_START
	    ld (.core.PRINT_JUMP_STATE), hl    ; Saves next entry call
	    call .core.__LOAD_S_POSN
	    ld e, a
	    ld hl, (.core.MAXX)
	    cp l
	    jr c, __PRINT_AT2_END
	    jr __PRINT_EOL1

.core.__PRINT_DEL:
	    call .core.__LOAD_S_POSN        ; Gets current screen position
	    dec e
	    ld a, -1
	    cp e
	    jp nz, __PRINT_AT2_END
	    ld hl, (.core.MAXX)
	    ld e, l
	    dec e
	    dec e
	    dec d
	    cp d
	    jp nz, __PRINT_AT2_END
	    ld d, h
	    dec d
	    jp __PRINT_AT2_END

__PRINT_INK:
	    ld hl, .core.__PRINT_INK2
	    jp __PRINT_SET_STATE

.core.__PRINT_INK2:
	    exx
	    call .core.INK_TMP
	    jp .core.__PRINT_RESTART

__PRINT_PAP:
	    ld hl, .core.__PRINT_PAP2
	    jp __PRINT_SET_STATE

.core.__PRINT_PAP2:
	    exx
	    call .core.PAPER_TMP
	    jp .core.__PRINT_RESTART

.core.__PRINT_FLA:
	    ld hl, .core.__PRINT_FLA2
	    jp __PRINT_SET_STATE

.core.__PRINT_FLA2:
	    exx
	    call .core.FLASH_TMP
	    jp .core.__PRINT_RESTART

.core.__PRINT_BRI:
	    ld hl, .core.__PRINT_BRI2
	    jp __PRINT_SET_STATE

.core.__PRINT_BRI2:
	    exx
	    call .core.BRIGHT_TMP
	    jp .core.__PRINT_RESTART

.core.__PRINT_INV:
	    ld hl, .core.__PRINT_INV2
	    jp __PRINT_SET_STATE

.core.__PRINT_INV2:
	    exx
	    call .core.INVERSE_TMP
	    jp .core.__PRINT_RESTART

.core.__PRINT_OVR:
	    ld hl, .core.__PRINT_OVR2
	    jp __PRINT_SET_STATE

.core.__PRINT_OVR2:
	    exx
	    call .core.OVER_TMP
	    jp .core.__PRINT_RESTART

__PRINT_BOLD:
	    ld hl, __PRINT_BOLD2
	    jp __PRINT_SET_STATE

__PRINT_BOLD2:
	    exx
	    call .core.BOLD_TMP
	    jp .core.__PRINT_RESTART

__PRINT_ITA:
	    ld hl, __PRINT_ITA2
	    jp __PRINT_SET_STATE

__PRINT_ITA2:
	    exx
	    call .core.ITALIC_TMP
	    jp .core.__PRINT_RESTART


__BOLD:
	    push hl
	    ld hl, .core.MEM0
	    ld b, 8
__BOLD_LOOP:
	    ld a, (de)
	    ld c, a
	    rlca
	    or c
	    ld (hl), a
	    inc hl
	    inc de
	    djnz __BOLD_LOOP
	    pop hl
	    ld de, .core.MEM0
	    ret


__ITALIC:
	    push hl
	    ld hl, .core.MEM0
	    ex de, hl
	    ld bc, 8
	    ldir
	    ld hl, .core.MEM0
	    srl (hl)
	    inc hl
	    srl (hl)
	    inc hl
	    srl (hl)
	    inc hl
	    inc hl
	    inc hl
	    sla (hl)
	    inc hl
	    sla (hl)
	    inc hl
	    sla (hl)
	    pop hl
	    ld de, .core.MEM0
	    ret

.core.PRINT_COMMA:
	    call .core.__LOAD_S_POSN
	    ld a, e
	    and 16
	    add a, 16

.core.PRINT_TAB:
	    PROC
	    LOCAL LOOP, CONTINUE

	    inc a
	    call .core.__LOAD_S_POSN ; e = current row
	    ld d, a
	    ld a, e
	    cp 21h
	    jr nz, CONTINUE
	    ld e, -1
CONTINUE:
	    ld a, d
	    inc e
	    sub e  ; A = A - E
	    and 31 ;
	    ret z  ; Already at position E
	    ld b, a
LOOP:
	    ld a, ' '
	    push bc
	    exx
	    call .core.__PRINTCHAR
	    exx
	    pop bc
	    djnz LOOP
	    ret
	    ENDP

.core.PRINT_AT: ; Changes cursor to ROW, COL
	    ; COL in A register
	    ; ROW in stack

	    pop hl    ; Ret address
	    ex (sp), hl ; callee H = ROW
	    ld l, a
	    ex de, hl

	    call .core.__IN_SCREEN
	    ret nc    ; Return if out of screen

	    ld hl, __TVFLAGS
	    res 1, (hl)
#line 485 "C:/zxbasic/src/arch/zx48k/library-asm/print.asm"
	    jp .core.__SAVE_S_POSN

	    LOCAL __PRINT_COM
	    LOCAL __BOLD
	    LOCAL __BOLD_LOOP
	    LOCAL __ITALIC
	    LOCAL __PRINT_EOL1
	    LOCAL __PRINT_EOL2
	    LOCAL __PRINT_AT1
	    LOCAL __PRINT_AT2
	    LOCAL __PRINT_AT2_END
	    LOCAL __PRINT_BOLD
	    LOCAL __PRINT_BOLD2
	    LOCAL __PRINT_ITA
	    LOCAL __PRINT_ITA2
	    LOCAL __PRINT_INK
	    LOCAL __PRINT_PAP
	    LOCAL __PRINT_SET_STATE
	    LOCAL __PRINT_TABLE
	    LOCAL __PRINT_TAB, __PRINT_TAB1, __PRINT_TAB2

__PRINT_TABLE:    ; Jump table for 0 .. 22 codes

	    DW .core.__PRINT_NOP    ;  0
	    DW .core.__PRINT_NOP    ;  1
	    DW .core.__PRINT_NOP    ;  2
	    DW .core.__PRINT_NOP    ;  3
	    DW .core.__PRINT_NOP    ;  4
	    DW .core.__PRINT_NOP    ;  5
	    DW __PRINT_COM    ;  6 COMMA
	    DW .core.__PRINT_NOP    ;  7
	    DW .core.__PRINT_DEL    ;  8 DEL
	    DW .core.__PRINT_NOP    ;  9
	    DW .core.__PRINT_NOP    ; 10
	    DW .core.__PRINT_NOP    ; 11
	    DW .core.__PRINT_NOP    ; 12
	    DW .core.__PRINT_0Dh    ; 13
	    DW __PRINT_BOLD   ; 14
	    DW __PRINT_ITA    ; 15
	    DW __PRINT_INK    ; 16
	    DW __PRINT_PAP    ; 17
	    DW .core.__PRINT_FLA    ; 18
	    DW .core.__PRINT_BRI    ; 19
	    DW .core.__PRINT_INV    ; 20
	    DW .core.__PRINT_OVR    ; 21
	    DW .core.__PRINT_AT     ; 22 AT
	    DW __PRINT_TAB    ; 23 TAB

	    ENDP



#line 429 "C:/Users/geniw/source/repos/PathFindingLibrary/PathFindingLibrary/ZxBasicFiles/PathFinding.zxbas"
#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/printstr.asm"



#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/free.asm"
; vim: ts=4:et:sw=4:
	; Copyleft (K) by Jose M. Rodriguez de la Rosa
	;  (a.k.a. Boriel)
;  http://www.boriel.com
	;
	; This ASM library is licensed under the BSD license
	; you can use it for any purpose (even for commercial
	; closed source programs).
	;
	; Please read the BSD license on the internet

	; ----- IMPLEMENTATION NOTES ------
	; The heap is implemented as a linked list of free blocks.

; Each free block contains this info:
	;
	; +----------------+ <-- HEAP START
	; | Size (2 bytes) |
	; |        0       | <-- Size = 0 => DUMMY HEADER BLOCK
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   | <-- If Size > 4, then this contains (size - 4) bytes
	; | (0 if Size = 4)|   |
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   |
	; | (0 if Size = 4)|   |
	; +----------------+   |
	;   <Allocated>        | <-- This zone is in use (Already allocated)
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   |
	; | (0 if Size = 4)|   |
	; +----------------+ <-+
	; | Next (2 bytes) |--> NULL => END OF LIST
	; |    0 = NULL    |
	; +----------------+
	; | <free bytes...>|
	; | (0 if Size = 4)|
	; +----------------+


	; When a block is FREED, the previous and next pointers are examined to see
	; if we can defragment the heap. If the block to be breed is just next to the
	; previous, or to the next (or both) they will be converted into a single
	; block (so defragmented).


	;   MEMORY MANAGER
	;
	; This library must be initialized calling __MEM_INIT with
	; HL = BLOCK Start & DE = Length.

	; An init directive is useful for initialization routines.
	; They will be added automatically if needed.

#line 1 "C:/zxbasic/src/arch/zx48k/library-asm/heapinit.asm"
; vim: ts=4:et:sw=4:
	; Copyleft (K) by Jose M. Rodriguez de la Rosa
	;  (a.k.a. Boriel)
;  http://www.boriel.com
	;
	; This ASM library is licensed under the BSD license
	; you can use it for any purpose (even for commercial
	; closed source programs).
	;
	; Please read the BSD license on the internet

	; ----- IMPLEMENTATION NOTES ------
	; The heap is implemented as a linked list of free blocks.

; Each free block contains this info:
	;
	; +----------------+ <-- HEAP START
	; | Size (2 bytes) |
	; |        0       | <-- Size = 0 => DUMMY HEADER BLOCK
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   | <-- If Size > 4, then this contains (size - 4) bytes
	; | (0 if Size = 4)|   |
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   |
	; | (0 if Size = 4)|   |
	; +----------------+   |
	;   <Allocated>        | <-- This zone is in use (Already allocated)
	; +----------------+ <-+
	; | Size (2 bytes) |
	; +----------------+
	; | Next (2 bytes) |---+
	; +----------------+   |
	; | <free bytes...>|   |
	; | (0 if Size = 4)|   |
	; +----------------+ <-+
	; | Next (2 bytes) |--> NULL => END OF LIST
	; |    0 = NULL    |
	; +----------------+
	; | <free bytes...>|
	; | (0 if Size = 4)|
	; +----------------+


	; When a block is FREED, the previous and next pointers are examined to see
	; if we can defragment the heap. If the block to be breed is just next to the
	; previous, or to the next (or both) they will be converted into a single
	; block (so defragmented).


	;   MEMORY MANAGER
	;
	; This library must be initialized calling __MEM_INIT with
	; HL = BLOCK Start & DE = Length.

	; An init directive is useful for initialization routines.
	; They will be added automatically if needed.




	; ---------------------------------------------------------------------
	;  __MEM_INIT must be called to initalize this library with the
	; standard parameters
	; ---------------------------------------------------------------------

.core.__MEM_INIT: ; Initializes the library using (RAMTOP) as start, and
	    ld hl, .core.ZXBASIC_MEM_HEAP  ; Change this with other address of heap start
	    ld de, .core.ZXBASIC_HEAP_SIZE ; Change this with your size

	; ---------------------------------------------------------------------
	;  .core.__MEM_INIT2 initalizes this library
; Parameters:
;   HL : Memory address of 1st byte of the memory heap
;   DE : Length in bytes of the Memory Heap
	; ---------------------------------------------------------------------
.core.__MEM_INIT2:
	    ; HL as TOP
	    PROC

	    dec de
	    dec de
	    dec de
	    dec de        ; DE = length - 4; HL = start
	    ; This is done, because we require 4 bytes for the empty dummy-header block

	    xor a
	    ld (hl), a
	    inc hl
    ld (hl), a ; First "free" block is a header: size=0, Pointer=&(Block) + 4
	    inc hl

	    ld b, h
	    ld c, l
	    inc bc
	    inc bc      ; BC = starts of next block

	    ld (hl), c
	    inc hl
	    ld (hl), b
	    inc hl      ; Pointer to next block

	    ld (hl), e
	    inc hl
	    ld (hl), d
	    inc hl      ; Block size (should be length - 4 at start); This block contains all the available memory

	    ld (hl), a ; NULL (0000h) ; No more blocks (a list with a single block)
	    inc hl
	    ld (hl), a

	    ld a, 201
	    ld (.core.__MEM_INIT), a; "Pokes" with a RET so ensure this routine is not called again
	    ret

	    ENDP


#line 69 "C:/zxbasic/src/arch/zx48k/library-asm/free.asm"

	; ---------------------------------------------------------------------
	; MEM_FREE
	;  Frees a block of memory
	;
; Parameters:
	;  HL = Pointer to the block to be freed. If HL is NULL (0) nothing
	;  is done
	; ---------------------------------------------------------------------


.core.MEM_FREE:
.core.__MEM_FREE: ; Frees the block pointed by HL
	    ; HL DE BC & AF modified
	    PROC

	    LOCAL __MEM_LOOP2
	    LOCAL __MEM_LINK_PREV
	    LOCAL __MEM_JOIN_TEST
	    LOCAL __MEM_BLOCK_JOIN

	    ld a, h
	    or l
	    ret z       ; Return if NULL pointer

	    dec hl
	    dec hl
	    ld b, h
	    ld c, l    ; BC = Block pointer

	    ld hl, .core.ZXBASIC_MEM_HEAP  ; This label point to the heap start

__MEM_LOOP2:
	    inc hl
	    inc hl     ; Next block ptr

	    ld e, (hl)
	    inc hl
	    ld d, (hl) ; Block next ptr
	    ex de, hl  ; DE = &(block->next); HL = block->next

	    ld a, h    ; HL == NULL?
	    or l
	    jp z, __MEM_LINK_PREV; if so, link with previous

	    or a       ; Clear carry flag
	    sbc hl, bc ; Carry if BC > HL => This block if before
	    add hl, bc ; Restores HL, preserving Carry flag
	    jp c, __MEM_LOOP2 ; This block is before. Keep searching PASS the block

	;------ At this point current HL is PAST BC, so we must link (DE) with BC, and HL in BC->next

__MEM_LINK_PREV:    ; Link (DE) with BC, and BC->next with HL
	    ex de, hl
	    push hl
	    dec hl

	    ld (hl), c
	    inc hl
	    ld (hl), b ; (DE) <- BC

	    ld h, b    ; HL <- BC (Free block ptr)
	    ld l, c
	    inc hl     ; Skip block length (2 bytes)
	    inc hl
	    ld (hl), e ; Block->next = DE
	    inc hl
	    ld (hl), d
	    ; --- LINKED ; HL = &(BC->next) + 2

	    call __MEM_JOIN_TEST
	    pop hl

__MEM_JOIN_TEST:   ; Checks for fragmented contiguous blocks and joins them
	    ; hl = Ptr to current block + 2
	    ld d, (hl)
	    dec hl
	    ld e, (hl)
	    dec hl
	    ld b, (hl) ; Loads block length into BC
	    dec hl
	    ld c, (hl) ;

	    push hl    ; Saves it for later
	    add hl, bc ; Adds its length. If HL == DE now, it must be joined
	    or a
	    sbc hl, de ; If Z, then HL == DE => We must join
	    pop hl
	    ret nz

__MEM_BLOCK_JOIN:  ; Joins current block (pointed by HL) with next one (pointed by DE). HL->length already in BC
	    push hl    ; Saves it for later
	    ex de, hl

	    ld e, (hl) ; DE -> block->next->length
	    inc hl
	    ld d, (hl)
	    inc hl

	    ex de, hl  ; DE = &(block->next)
	    add hl, bc ; HL = Total Length

	    ld b, h
	    ld c, l    ; BC = Total Length

	    ex de, hl
	    ld e, (hl)
	    inc hl
	    ld d, (hl) ; DE = block->next

	    pop hl     ; Recovers Pointer to block
	    ld (hl), c
	    inc hl
	    ld (hl), b ; Length Saved
	    inc hl
	    ld (hl), e
	    inc hl
	    ld (hl), d ; Next saved
	    ret

	    ENDP


#line 5 "C:/zxbasic/src/arch/zx48k/library-asm/printstr.asm"

	; PRINT command routine
	; Prints string pointed by HL


.core.PRINT_STR:
.core.__PRINTSTR:		; __FASTCALL__ Entry to print_string
	    PROC
	    LOCAL __PRINT_STR_LOOP
	    LOCAL __PRINT_STR_END

	    ld d, a ; Saves A reg (Flag) for later

	    ld a, h
	    or l
	    ret z	; Return if the pointer is NULL

	    push hl

	    ld c, (hl)
	    inc hl
	    ld b, (hl)
	    inc hl	; BC = LEN(a$); HL = &a$

__PRINT_STR_LOOP:
	    ld a, b
	    or c
	    jr z, __PRINT_STR_END 	; END if BC (counter = 0)

	    ld a, (hl)
	    call .core.__PRINTCHAR
	    inc hl
	    dec bc
	    jp __PRINT_STR_LOOP

__PRINT_STR_END:
	    pop hl
	    ld a, d ; Recovers A flag
	    or a   ; If not 0 this is a temporary string. Free it
	    ret z
	    jp .core.__MEM_FREE ; Frees str from heap and return from there

.core.__PRINT_STR:
	    ; Fastcall Entry
	    ; It ONLY prints strings
	    ; HL = String start
	    ; BC = String length (Number of chars)
	    push hl ; Push str address for later
	    ld d, a ; Saves a FLAG
	    jp __PRINT_STR_LOOP

	    ENDP


#line 430 "C:/Users/geniw/source/repos/PathFindingLibrary/PathFindingLibrary/ZxBasicFiles/PathFinding.zxbas"

	END
